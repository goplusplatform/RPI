# Принцип работы:

## Модуль things 

Библиотека goplus-py работает в качестве враппера для протокола обмена сообщениями платформы Go+. Для этого в ней реализуется базовый класс Thing. Для создания данного класа необходимо передать только идентификатор устройства на платформе. Для работы с платформой реализованы следующие методы:
* get(action, value) - служебный метод, впаппер для HTTP GET запроса
* ack(value) - передача подтверждения от устройства после установки какойто величины
* put(value) - передача нового сообщения от устройства
* event() - передача нового события от устройства
* message(message) - передача нового текстового сообшения на платформу  
* post_image(binary_data) - передача нового изображения на платформу

Данные методы реализуют весь основной функционал необходимый для взаимодействия с платформой. Так как работать с универсальным устройством требует от разработчика знания семантики обмена сообщениями, а также так как некоторые из устройств требуют дополнительного функционала было принято решение создать набор классов наследников реализующих основные типы устройств с одним-двумя базовыми методами.

Следующая таблица демонстрирует основные типы устройств, конструкторы для их создания и базовые методы для отправки сообщений на сервер.

| Устройство | Конструктор | Методы |
| --- | --- | --- |
| Data | (did) | update(value) |
| Geo | (did) | update(lat, lon) |
| Alert | (did) | update() |
| Button | (did) | increase(), decrease() |
| Message | (did) | update(message) |
| Stream | (did) | update(image_data), update_from_jpeg(image_filename) |
| Level | (did, user_id, set_handler, get_handler) | start_loop() |
| Switch | (did, user_id, set_on, set_off) | start_loop() |

1. Метды update вызывают методы, специфичные для устройства. Стоит заметить что для устройств Stream, существует два метода, один принимает в качестве параметров бинарные данные изображения, а второй имя файла с изображением.
2. Устройста Level и Switch используют протокол mqtt для получения данных с сервера. Для того чтобы подписаться на специфичный для устройства канал в mqtt необходимо передать вторым параметром идентификатор пользователя в платформе. 
3. Для реагирования на сообшения для устройства Level необходимо передать функции set_handler и get_handler которые будут вызваны при поступлении set и get запросов. set_handler запускается с параметром value и должно вернуть фактически установленное значение или None в случае ошибки. get_handler запускается без параметров и возвращает текущее значение или None в случае ошибки.
4. Устройство типа Switch принимает на вход функции set_on и set_off которые будут выполнены без параметров при получени команд включить или выключить.     

## Модуль gpio

Данный модуль реализует универсальный интерфейс для работы с цифровыми пинами GPIO на платформах Raspberry Pi и Intel Edison. Для этого данный модуль реализует класс GPIO. Конструктор класса принимает три параметра:
* platform - платформа для которой создается пин. В данной версии реализовано два типа - "rpi" и "edison"
* pin_number - номер пина на выбранной платформе
* pin_type - тип пина, может быть "input" или "output"   

В зависимости от выбранной платформы будет создан экземпляр класса специфичного для платформы. Обьект класса GPIO имеет следующие методы:
* on() - включение output пина 
* off() - выключение output пина
* read() - чтение состояния input пина

Методы on и off могут быть использованы при создании устройств типа Switch и Level.

# Инструкция по применению

## Установка

Библиотека для работы с сервисом Go+ размещена в стандартном репозитории пакетов PyPi. Установка может быть выполненна станадртными средствами `python`.

Для устрановки библиотеки необходимо выполнить команду `pip install goplus-py`. В ходе установки `pip` самостоятельно скачает два зависимости, необходимые для работы библиотеки: `paho-mqtt` и `requests`.

## Устройство типа DATA

После успешной загрузки можно приступать у созданию собственных интернет вещей. Разберем на примере как логировать температуру в комнате.

```
from goplus import *

device = things.Data('YOUR_DEVICE_ID')

while True:
    data = get_temp()
    
    # send data to GO+ platform
    resp = device.update(data)
    print("Result: " + resp)

    time.sleep(60)
```

В первой строке мы импортируем все функции и классы предоставляемые библиотекой goplus. После чего нам необходимо создать устройство. В данном случае мы будем создавать устройства типа Data. Для создания устройства нам необходимо знать уникальный идентификатор, котрый можно посмотреть в параметрах устройства на портале Go+.

Далее мы создаем бесконечный цикл и выполянием последовательно следующие команды:
* получаем данные от датчика температуры в виде целого или дробного числа (реализация данной функции остается за пределами мануала так как она будет менятся в зависимости от используемого устройства, типа подключения датчика и т.д.)
* отправляем данные на сервер Go+ (почти все устройства реализуют функцию update для отправки данных на сервер, но принимают разный набор параметров, таблица с параметрами будет приведена ниже)
* печатаем ответ сервера
* засыпаем на 60 секунд 

## Актуатор с возможностью управления с платформы

Также библиотека позволяет создавать устройства с возможностью управления с платформы. В этом случае устройство подключается по протоколу MQTT и ожидает команд на специальном канале. Предположим мы хотим управлять светодиодом или реле, подключенным к одноми из GPIO пинов Raspberry Pi. 

В библиотеке реализованы унифицированные врапперы над основными библиотеками для работы с GPIO на платформе Raspberry Pi и Intel Edison. Прежде всего нам необходимо установить опциональную зависимость `RPi.GPIO`. Это можно сделать с помощью команды `pip install goplus-py[rpi]`.

Код для нашего устройства будет выглядеть следующим образом:
```
from goplus import *

pin_number = 10
pin = gpio.GPIO("rpi", pin_number, 'output')

device = things.Switch('YOUR_DEVICE_ID', 'YOUR_USER_ID', pin.on, pin.off)
device.start_loop()
```

Как и прежде в первой строке мы импортируем все классы и функции библиотеки goplus. Далее мы задаем номер GPIO пина которым мы хотим управлять и создаем экземпляр класса gpio.GPIO. Данный обьект характеризуется тремя параметрами:
* Тип устройства - поддерживается "rpi" для Raspberry Pi и "edison" для Intel Edison
* Номер пина
* Тип пина - может принимать значение "output" и "input"  

После этого мы можем создавать устройство типа Switch. Первыми двумя параметрами для создания устройства мы передаем идентификатор устройства и идентификатор пользователя (он необходим для выбора MQTT топика для данного устройства). Далее нам необходимо указать две функции которые будут выполнены когда Устройство получит команду включиться и выключиться соответственно. Мы используем функции предоставленные созданным экземпляром класса gpio.GPIO. В отличии от устройств типа Data у нас нет необходимости создавать бесконечный цикл, мы можем воспользоваться циклом предоставляемым пакетом MQTT. Для этого мы воспользуемся функцией `device.start_loop()`. 

## Таблица устройств

| Устройство | Конструктор | Методы |
| --- | --- | --- |
| Data | (did) | update(value) |
| Geo | (did) | update(lat, lon) |
| Alert | (did) | update() |
| Button | (did) | increase(), decrease() |
| Message | (did) | update(message) |
| Stream | (did) | update(image_data), update_from_jpeg(image_filename) |
| Level | (did, user_id, set_handler, get_handler) | start_loop() |
| Switch | (did, user_id, set_on, set_off) | start_loop() |

1. Метды update вызывают методы, специфичные для устройства. Стоит заметить что для устройств Stream, существует два метода, один принимает в качестве параметров бинарные данные изображения, а второй имя файла с изображением.
2. Устройста Level и Switch используют протокол mqtt для получения данных с сервера. Для того чтобы подписаться на специфичный для устройства канал в mqtt необходимо передать вторым параметром идентификатор пользователя в платформе. 
3. Для реагирования на сообшения для устройства Level необходимо передать функции set_handler и get_handler которые будут вызваны при поступлении set и get запросов. set_handler запускается с параметром value и должно вернуть фактически установленное значение или None в случае ошибки. get_handler запускается без параметров и возвращает текущее значение или None в случае ошибки.
4. Устройство типа Switch принимает на вход функции set_on и set_off которые будут выполнены без параметров при получени команд включить или выключить. 
